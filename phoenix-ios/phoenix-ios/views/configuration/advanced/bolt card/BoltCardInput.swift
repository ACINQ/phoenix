import Foundation
import DnaCommunicator

/// Versioning information
enum BoltCardVersion {
	
	/// Version 1 was the original version.
	/// The card contains a lnurl-withdraw address, along with the values dynamically generated by the card.
	///
	/// E.g.: https://phoenix.app/lnurlw?id=abc123&picc_data=X&cmac=Y
	case V1
	
	/// Version 1 & 2 combines the lnurl-withdraw address along with a `v2` queryParameter,
	/// for those services that support both versions.
	///
	/// E.g.: https://phoenix.app/lnurlw?id=abc123&v2=alice@phoenixwallet.me&picc_data=X&cmac=Y
	case V1AndV2
	
	/// Version 2 is the new lightning-only version.
	/// (Add link to documentation here...)
	///
	/// E.g.: ₿alice@phoenixwallet.me?picc_data=X&cmac=Y
	///
	case V2
}

/// Required input to create a new NFC card.
/// Multiple versions are supported (at least for testing/debug purposes).
///
enum BoltCardInput: Codable {
	case V1(lnurlWithdrawId: String)
	case V1AndV2(lnurlWithdrawId: String, lnAddress: String)
	case V2(lnAddress: String)
	
	var version: BoltCardVersion {
		switch self {
		case .V1:
			return .V1
		case .V1AndV2:
			return .V1AndV2
		case .V2:
			return .V2
		}
	}
	
	func toTemplate() -> Ndef.Template {
		
		let lnurlWithdrawBaseUrl = URL(string: "https://phoenix.deusty.com/v1/pub/lnurlw/info")!
		var queryItems: [URLQueryItem] = []
		
		switch self {
		case .V1(let lnurlWithdrawId):
			queryItems.append(URLQueryItem(name: "id", value: lnurlWithdrawId))
			
			var comps = URLComponents(url: lnurlWithdrawBaseUrl, resolvingAgainstBaseURL: false)!
			comps.queryItems = queryItems
			let resolvedUrl = comps.url!
			
			return Ndef.Template(baseUrl: resolvedUrl)!
			
		case .V1AndV2(let lnurlWithdrawId, let lnAddress):
			let sanitizedLnAddress = lnAddress.starts(with: "₿") ? lnAddress : "₿\(lnAddress)"
			
			queryItems.append(URLQueryItem(name: "id", value: lnurlWithdrawId))
			queryItems.append(URLQueryItem(name: "v2", value: sanitizedLnAddress))
			
			var comps = URLComponents(url: lnurlWithdrawBaseUrl, resolvingAgainstBaseURL: false)!
			comps.queryItems = queryItems
			let resolvedUrl = comps.url!
			
			return Ndef.Template(baseUrl: resolvedUrl)!
			
		case .V2(let lnAddress):
			let sanitizedLnAddress = lnAddress.starts(with: "₿") ? lnAddress : "₿\(lnAddress)"
			
			return Ndef.Template(baseText: sanitizedLnAddress)
		}
	}
}

/// The iOS simulator doesn't support NFC.
/// So the simulator has no way to write to an NFC card.
/// But you can link a card to a simulator wallet for testing.
///
struct SimulatorBoltCardInput: Codable {
	let key0: String
	let chipUid: String
}
