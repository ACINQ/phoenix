/*
 * Copyright 2024 ACINQ SAS
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fr.acinq.phoenix.utils.channels

import fr.acinq.bitcoin.ByteVector
import fr.acinq.bitcoin.ByteVector64
import fr.acinq.bitcoin.Crypto
import fr.acinq.bitcoin.KeyPath
import fr.acinq.bitcoin.PublicKey
import fr.acinq.bitcoin.Satoshi
import fr.acinq.bitcoin.SigHash
import fr.acinq.bitcoin.SigVersion
import fr.acinq.bitcoin.Script
import fr.acinq.bitcoin.Transaction
import fr.acinq.bitcoin.TxId
import fr.acinq.bitcoin.byteVector
import fr.acinq.lightning.channel.states.ChannelStateWithCommitments
import fr.acinq.lightning.channel.states.PersistedChannelState
import fr.acinq.lightning.logging.error
import fr.acinq.lightning.serialization.channel.Encryption.from
import fr.acinq.lightning.serialization.channel.Serialization
import fr.acinq.lightning.transactions.Scripts
import fr.acinq.lightning.transactions.Transactions
import fr.acinq.phoenix.PhoenixBusiness
import fr.acinq.secp256k1.Hex
import kotlinx.coroutines.flow.filterNotNull
import kotlinx.coroutines.flow.first

object SpendChannelAddressHelper {

    /**
     * This method signs a transaction that spends the outpoint of a channel. The goal is to recover funds that were accidentally sent
     * to a channel address (sometimes users think they can reverse a splice-out this way).
     *
     * @param channelData the encrypted channel data, that need to be decrypted to get the channel's funding key path
     * @param remoteFundingPubkey LSP funding pubkey
     * @param unsignedTx the refund transaction generated by the LSP
     *
     * @return a pair of (public key, signature)
     */
    suspend fun spendFromChannelAddress(
        business: PhoenixBusiness,
        amount: Satoshi,
        fundingTxIndex: Long,
        channelKeyPath: String,
        remoteFundingPubkey: String,
        unsignedTx: String
    ): SpendChannelAddressResult {
        val loggerFactory = business.loggerFactory
        val log = loggerFactory.newLogger(this::class)
        val peer = business.peerManager.getPeer()

        val tx = try {
            Transaction.read(unsignedTx)
        } catch (e: Exception) {
            log.error(e) { "failed to read transaction hex" }
            return SpendChannelAddressResult.Failure.TransactionMalformed(e.message ?: e::class.simpleName.toString())
        }

        val pubkey = try {
            PublicKey.fromHex(remoteFundingPubkey)
        } catch (e: Exception) {
            log.error(e) { "failed to read remote-funding-pubkey" }
            return SpendChannelAddressResult.Failure.RemoteFundingPubkeyMalformed(e.message ?: e::class.simpleName.toString())
        }

        val channelKeys = try {
            peer.nodeParams.keyManager.channelKeys(KeyPath(channelKeyPath))
        } catch (e: Exception) {
            log.error(e) { "failed to read channel keypath=$channelKeyPath" }
            return SpendChannelAddressResult.Failure.InvalidChannelKeyPath
        }

        try {
            val localFundingKey = channelKeys.fundingKey(fundingTxIndex)
            val fundingScript = Scripts.multiSig2of2(localFundingKey.publicKey(), pubkey)

            val sig = TODO() //Transactions.sign(tx = tx, inputIndex = 0, Script.write(fundingScript), amount, localFundingKey)
            val signedData = tx.hashForSigning(0, Script.write(fundingScript), SigHash.SIGHASH_ALL, amount, SigVersion.SIGVERSION_WITNESS_V0)

            try {
                val verifySig = Crypto.verifySignature(signedData, sig, localFundingKey.publicKey())
                if (!verifySig) {
                    log.error { "signature not verified" }
                    SpendChannelAddressResult.Failure.InvalidSig(tx.txid, localFundingKey.publicKey(), Script.write(fundingScript).byteVector(), sig)
                } else {
                    SpendChannelAddressResult.Success(tx.txid, localFundingKey.publicKey(), Script.write(fundingScript).byteVector(), sig)
                }
            } catch (e: Exception) {
                log.error(e) { "failed to verify signature" }
                SpendChannelAddressResult.Failure.InvalidSig(tx.txid, localFundingKey.publicKey(), Script.write(fundingScript).byteVector(), sig)
            }

        } catch (e: Exception) {
            log.error(e) { "failed to sign transaction" }
            return SpendChannelAddressResult.Failure.Generic(e)
        }
    }
}

sealed class SpendChannelAddressResult {
    data class Success(val txId: TxId, val publicKey: PublicKey, val fundingScript: ByteVector, val signature: ByteVector64) : SpendChannelAddressResult()
    sealed class Failure : SpendChannelAddressResult() {
        data class Generic(val error: Throwable) : Failure()
        data object InvalidChannelKeyPath : Failure()
        data class TransactionMalformed(val details: String) : Failure()
        data class RemoteFundingPubkeyMalformed(val details: String) : Failure()
        data class InvalidSig(val txId: TxId, val publicKey: PublicKey, val fundingScript: ByteVector, val signature: ByteVector64) : Failure()
    }
}