/*
 * Copyright 2024 ACINQ SAS
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fr.acinq.phoenix.utils.channels

import fr.acinq.bitcoin.ByteVector
import fr.acinq.bitcoin.ByteVector32
import fr.acinq.bitcoin.ByteVector64
import fr.acinq.bitcoin.Crypto
import fr.acinq.bitcoin.PublicKey
import fr.acinq.bitcoin.Satoshi
import fr.acinq.bitcoin.Script
import fr.acinq.bitcoin.Transaction
import fr.acinq.bitcoin.TxId
import fr.acinq.bitcoin.TxOut
import fr.acinq.bitcoin.byteVector
import fr.acinq.bitcoin.crypto.musig2.IndividualNonce
import fr.acinq.bitcoin.crypto.musig2.Musig2
import fr.acinq.bitcoin.utils.Either
import fr.acinq.lightning.Lightning.randomBytes32
import fr.acinq.lightning.channel.states.ChannelStateWithCommitments
import fr.acinq.lightning.channel.states.PersistedChannelState
import fr.acinq.lightning.logging.error
import fr.acinq.lightning.logging.info
import fr.acinq.lightning.serialization.channel.Encryption.fromEncryptedPeerStorage
import fr.acinq.lightning.serialization.channel.Serialization
import fr.acinq.lightning.transactions.Scripts
import fr.acinq.lightning.transactions.Transactions
import fr.acinq.lightning.wire.EncryptedPeerStorage
import fr.acinq.phoenix.PhoenixBusiness

object SpendChannelAddressHelper {

    /**
     * This method signs a transaction that spends the outpoint of a channel. The goal is to recover funds that were accidentally sent
     * to a channel address (sometimes users think they can reverse a splice-out this way).
     *
     * @param channelId the channel id tied to the channel's outpoint
     * @param channelData the encrypted channel data, that need to be decrypted to get the channel's funding key path
     * @param remoteFundingPubkeyRaw LSP funding pubkey
     * @param unsignedTx the refund transaction generated by the LSP
     *
     * @return a result class, either a success or a failure
     */
    suspend fun spendFromChannelAddress(
        business: PhoenixBusiness,
        amount: Satoshi,
        fundingTxIndex: Long,
        channelId: String,
        channelData: String,
        remoteFundingPubkeyRaw: String,
        unsignedTxRaw: String,
        remoteNonceRaw: String
    ): SpendChannelAddressResult {
        val loggerFactory = business.loggerFactory
        val log = loggerFactory.newLogger(this::class)
        val peer = business.peerManager.getPeer()

        log.info { "signing channel outpoint spending: [ channel_id=$channelId, channel_data=${channelData.take(20)}..., remote_pubkey=$remoteFundingPubkeyRaw, unsigned_tx=$unsignedTxRaw, remote_nonce=$remoteNonceRaw ]" }

        val remoteNonce = try {
            IndividualNonce(remoteNonceRaw)
        } catch (e: Exception) {
            log.error(e) { "failed to read remote nonce hex" }
            return SpendChannelAddressResult.Failure.RemoteNonceMalformed
        }

        val unsignedTx = try {
            Transaction.read(unsignedTxRaw)
        } catch (e: Exception) {
            log.error(e) { "failed to read transaction hex" }
            return SpendChannelAddressResult.Failure.TransactionMalformed(e.message ?: e::class.simpleName.toString())
        }

        val remoteFundingPubKey = try {
            PublicKey.fromHex(remoteFundingPubkeyRaw)
        } catch (e: Exception) {
            log.error(e) { "failed to read remote-funding-pubkey" }
            return SpendChannelAddressResult.Failure.RemoteFundingPubkeyMalformed(e.message ?: e::class.simpleName.toString())
        }

        val channelState = PersistedChannelState
            .fromEncryptedPeerStorage(peer.nodeParams.nodePrivateKey, EncryptedPeerStorage(ByteVector.fromHex(channelData)), null)
            .fold(
                onSuccess = {
                    when (it) {
                        is Serialization.PeerStorageDeserializationResult.UnknownVersion -> {
                            log.error { "unhandled channel data version: ${it.version}" }
                            return SpendChannelAddressResult.Failure.UnhandledChannelBackupVersion(it.version)
                        }
                        is Serialization.PeerStorageDeserializationResult.Success -> {
                            val matchingState = it.states.firstOrNull { it.channelId == ByteVector32.fromValidHex(channelId) }
                            when (matchingState) {
                                is ChannelStateWithCommitments -> matchingState
                                null -> {
                                    log.error { "no matching state for channel=$channelId" }
                                    return SpendChannelAddressResult.Failure.MissingChannelState
                                }
                                else -> {
                                    log.error { "unhandled channel data state=${matchingState.stateName}" }
                                    return SpendChannelAddressResult.Failure.UnhandledChannelState(matchingState.stateName)
                                }
                            }
                        }
                    }
                },
                onFailure = {
                    log.error(it) { "unreadable peer storage" }
                    return SpendChannelAddressResult.Failure.InvalidChannelBackup
                }
            )

        val channelKeyPath = channelState.commitments.channelParams.localParams.fundingKeyPath
        val channelKeys = peer.nodeParams.keyManager.channelKeys(channelKeyPath)

        try {
            val localFundingKey = channelKeys.fundingKey(fundingTxIndex)

            val outputScript = Script.pay2tr(internalKey = Scripts.Taproot.musig2Aggregate(localFundingKey.publicKey(), remoteFundingPubKey), Crypto.TaprootTweak.KeyPathTweak)
            val inputInfo = Transactions.InputInfo(unsignedTx.txIn.first().outPoint, TxOut(amount, outputScript))

            val tx = Transactions.SpliceTx(inputInfo, unsignedTx)
            val localNonce = Musig2.generateNonce(sessionId = randomBytes32(), signingKey = Either.Left(localFundingKey), publicKeys = listOf(localFundingKey.publicKey()), message = null, extraInput = null)
                .let { Transactions.LocalNonce(it.first, it.second) }

            val sigResult = tx.partialSign(localFundingKey, remoteFundingPubKey, extraUtxos = emptyMap(), localNonce = localNonce, publicNonces = listOf(localNonce.publicNonce, remoteNonce))
            return when (sigResult) {
                is Either.Left -> {
                    log.error(sigResult.value) { "failed to partially sign transaction" }
                    SpendChannelAddressResult.Failure.SigningFailure
                }
                is Either.Right -> {
                    log.info { "successfully generated partial signature" }
                    SpendChannelAddressResult.Success(txId = tx.tx.txid, publicKey = localFundingKey.publicKey(),
                        fundingScript = Script.write(outputScript).byteVector(), signature = sigResult.value.partialSig, localNonce = localNonce.publicNonce)
                }
            }
        } catch (e: Exception) {
            log.error(e) { "failed to sign transaction" }
            return SpendChannelAddressResult.Failure.Generic(e)
        }
    }
}

sealed class SpendChannelAddressResult {
    data class Success(val txId: TxId, val publicKey: PublicKey, val fundingScript: ByteVector, val signature: ByteVector32, val localNonce: IndividualNonce) : SpendChannelAddressResult()
    sealed class Failure : SpendChannelAddressResult() {
        data class Generic(val error: Throwable) : Failure()
        data object InvalidChannelBackup : Failure()
        data class UnhandledChannelBackupVersion(val version: Int) : Failure()
        data object MissingChannelState : Failure()
        data class UnhandledChannelState(val state: String) : Failure()
        data class TransactionMalformed(val details: String) : Failure()
        data object RemoteNonceMalformed : Failure()
        data class RemoteFundingPubkeyMalformed(val details: String) : Failure()
        data object SigningFailure : Failure()
    }
}