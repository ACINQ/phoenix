/*
 * Copyright 2024 ACINQ SAS
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fr.acinq.phoenix.utils.channels

import fr.acinq.bitcoin.ByteVector
import fr.acinq.bitcoin.ByteVector64
import fr.acinq.bitcoin.Crypto
import fr.acinq.bitcoin.PublicKey
import fr.acinq.bitcoin.Satoshi
import fr.acinq.bitcoin.SigHash
import fr.acinq.bitcoin.SigVersion
import fr.acinq.bitcoin.Script
import fr.acinq.bitcoin.Transaction
import fr.acinq.lightning.channel.states.ChannelStateWithCommitments
import fr.acinq.lightning.channel.states.PersistedChannelState
import fr.acinq.lightning.logging.error
import fr.acinq.lightning.serialization.channel.Encryption.from
import fr.acinq.lightning.serialization.channel.Serialization
import fr.acinq.lightning.transactions.Scripts
import fr.acinq.lightning.transactions.Transactions
import fr.acinq.lightning.wire.EncryptedChannelData
import fr.acinq.phoenix.PhoenixBusiness
import fr.acinq.secp256k1.Hex
import kotlinx.coroutines.flow.filterNotNull
import kotlinx.coroutines.flow.first

object SpendChannelAddressHelper {

    /**
     * This method signs a transaction that spends the outpoint of a channel. The goal is to recover funds that were accidentally sent
     * to a channel address (sometimes users think they can reverse a splice-out this way).
     *
     * @param channelData the encrypted channel data, that need to be decrypted to get the channel's funding key path
     * @param remoteFundingPubkey LSP funding pubkey
     * @param unsignedTx the refund transaction generated by the LSP
     *
     * @return a pair of (public key, signature)
     */
    suspend fun spendFromChannelAddress(
        business: PhoenixBusiness,
        amount: Satoshi,
        fundingTxIndex: Long,
        channelData: String,
        remoteFundingPubkey: String,
        unsignedTx: String
    ): SpendChannelAddressResult {
        val loggerFactory = business.loggerFactory
        val log = loggerFactory.newLogger(this::class)
        val peer = business.peerManager.getPeer()
        val nodeParams = business.nodeParamsManager.nodeParams.filterNotNull().first()

        val deserializedChannelData = try {
            EncryptedChannelData(ByteVector(Hex.decode(channelData)))
        } catch(e: Exception) {
            log.error(e) { "failed to deserialize channels-data blob" }
            return SpendChannelAddressResult.Failure.ChannelDataMalformed
        }

        val tx = try {
            Transaction.read(unsignedTx)
        } catch (e: Exception) {
            log.error(e) { "failed to read transaction hex" }
            return SpendChannelAddressResult.Failure.TransactionMalformed(e.message ?: e::class.simpleName.toString())
        }

        val pubkey = try {
            PublicKey.fromHex(remoteFundingPubkey)
        } catch (e: Exception) {
            log.error(e) { "failed to read remote-funding-pubkey" }
            return SpendChannelAddressResult.Failure.RemoteFundingPubkeyMalformed(e.message ?: e::class.simpleName.toString())
        }

        try {
            val channelKeyPath = PersistedChannelState.from(nodeParams.nodePrivateKey, deserializedChannelData)
                .fold(
                    onFailure = {
                        log.error { "failed to decrypt channel" }
                        return SpendChannelAddressResult.Failure.ChannelDataDecryption
                    },
                    onSuccess = {
                        when (it) {
                            is Serialization.DeserializationResult.Success -> {
                                when (val s = it.state) {
                                    is ChannelStateWithCommitments -> s.commitments.params.localParams.fundingKeyPath
                                    else -> {
                                        log.error { "unhandled channel data state: ${it::class.simpleName}" }
                                        return SpendChannelAddressResult.Failure.ChannelDataUnhandledState(it::class.simpleName)
                                    }
                                }
                            }
                            is Serialization.DeserializationResult.UnknownVersion -> {
                                log.error { "unhandled channel data version: ${it.version}" }
                                return SpendChannelAddressResult.Failure.ChannelDataUnhandledVersion(it.version)
                            }
                        }
                    }
                )

            val channelKeys = peer.nodeParams.keyManager.channelKeys(channelKeyPath)
            val localFundingKey = channelKeys.fundingKey(fundingTxIndex)
            val fundingScript = Scripts.multiSig2of2(localFundingKey.publicKey(), pubkey)

            val sig = Transactions.sign(tx = tx, inputIndex = 0, Script.write(fundingScript), amount, localFundingKey)
            val signedData = tx.hashForSigning(0, Script.write(fundingScript), SigHash.SIGHASH_ALL, amount, SigVersion.SIGVERSION_WITNESS_V0)
            if (!Crypto.verifySignature(signedData, sig, localFundingKey.publicKey())) {
                return SpendChannelAddressResult.Failure.InvalidSig(tx.txid, localFundingKey.publicKey(), Script.write(fundingScript).byteVector())
            } else {
                return SpendChannelAddressResult.Success(tx.txid, localFundingKey.publicKey(), Script.write(fundingScript).byteVector(), sig)
            }
        } catch (e: Exception) {
            log.error { "error when spending from channel address: ${e.message}" }
            return SpendChannelAddressResult.Failure.Generic(e)
        }
    }
}

sealed class SpendChannelAddressResult {
    data class Success(val txId: TxId, val publicKey: PublicKey, val fundingScript: ByteVector, val signature: ByteVector64) : SpendChannelAddressResult()
    sealed class Failure : SpendChannelAddressResult() {
        data class Generic(val error: Throwable) : Failure()
        data object ChannelDataMalformed : Failure()
        data object ChannelDataDecryption : Failure()
        data class ChannelDataUnhandledState(val stateName: String?) : Failure()
        data class ChannelDataUnhandledVersion(val version: Int) : Failure()
        data class TransactionMalformed(val details: String) : Failure()
        data class RemoteFundingPubkeyMalformed(val details: String) : Failure()
        data class InvalidSig(val txId: TxId, val publicKey: PublicKey, val fundingScript: ByteVector) : Failure()
    }
}